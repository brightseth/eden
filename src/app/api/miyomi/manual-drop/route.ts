/**
 * MIYOMI Manual Drop API
 * Triggers immediate pick generation and curation workflow
 */
import { NextRequest, NextResponse } from 'next/server';
import { miyomiSDK } from '@/lib/agents/miyomi-claude-sdk';
import { revenueEngine } from '@/lib/agents/miyomi-revenue-engine';

export const runtime = 'nodejs';

export async function POST(request: NextRequest) {
  try {
    // Parse JSON body if present, otherwise use defaults
    let agent_id = 'miyomi';
    let trigger_time = new Date().toISOString();
    
    try {
      const body = await request.json();
      agent_id = body.agent_id || agent_id;
      trigger_time = body.trigger_time || trigger_time;
    } catch {
      // No JSON body provided, use defaults
    }

    if (agent_id !== 'miyomi') {
      return NextResponse.json({ error: 'Invalid agent ID' }, { status: 400 });
    }

    console.log(`Manual drop triggered for ${agent_id} at ${trigger_time}`);

    // Step 1: Generate picks using Claude SDK
    const picks = await generateMarketPicks();
    
    if (!picks || picks.length === 0) {
      return NextResponse.json({ error: 'Failed to generate picks' }, { status: 500 });
    }

    // Step 2: Check for sponsorship opportunities
    const sponsoredPick = await applySponsorship(picks[0]);

    // Step 3: Send to curation queue 
    const pickId = await submitForCuration(sponsoredPick);

    // Step 4: If auto-approved, trigger Eden video generation
    const videoUrl = await triggerVideoGeneration(pickId, sponsoredPick);

    // Step 5: Create the drop record
    const dropId = await createDrop({
      agent_id,
      pick_id: pickId,
      video_url: videoUrl,
      triggered_manually: true,
      triggered_at: trigger_time,
      is_sponsored: sponsoredPick.isSponsored || false,
      sponsor_platform: sponsoredPick.sponsorPlatform
    });

    return NextResponse.json({ 
      success: true, 
      dropId,
      pickId,
      videoUrl,
      isSponsored: sponsoredPick.isSponsored,
      sponsorPlatform: sponsoredPick.sponsorPlatform,
      message: 'Manual drop completed successfully'
    });

  } catch (error) {
    console.error('Manual drop error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// Actual implementations using Claude SDK
async function generateMarketPicks() {
  try {
    console.log('Generating picks using Claude SDK...');
    
    // Generate picks using MIYOMI's Claude SDK
    const picks = await miyomiSDK.generatePicks(3);
    
    if (!picks || picks.length === 0) {
      throw new Error('No picks generated by Claude SDK');
    }

    // Add metadata and IDs
    const enrichedPicks = picks.map(pick => ({
      ...pick,
      id: `pick_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      generated_at: new Date().toISOString(),
      status: 'pending_curation'
    }));

    console.log(`Generated ${enrichedPicks.length} picks:`, enrichedPicks.map(p => p.market));
    return enrichedPicks;

  } catch (error) {
    console.error('Error generating picks with Claude SDK:', error);
    
    // Fallback to mock pick if Claude SDK fails
    const mockPick = {
      id: `pick_fallback_${Date.now()}`,
      market: 'Emergency Mock Pick - Fed Rates March 2025',
      platform: 'Kalshi' as const,
      position: 'NO' as const,
      confidence: 0.75,
      edge: 0.15,
      odds: 0.60,
      reasoning: 'Fallback pick generated due to Claude SDK failure',
      sector: 'finance' as const,
      risk_level: 'medium' as const,
      timeframe: '2025-03-20',
      sources: ['Emergency fallback'],
      generated_at: new Date().toISOString(),
      status: 'pending_curation',
      is_fallback: true
    };

    return [mockPick];
  }
}

async function submitForCuration(pick: any) {
  // TODO: Submit to curation workflow
  // This could auto-approve based on confidence threshold or send to human review
  
  console.log('Submitting pick for curation:', pick.id);
  
  // Mock auto-approval for high confidence picks
  if (pick.confidence > 0.75) {
    return pick.id;
  }
  
  // Otherwise, add to pending review queue
  return pick.id;
}

async function triggerVideoGeneration(pickId: string, pick?: any) {
  try {
    console.log('Triggering video generation for pick:', pickId);
    
    // Use our new video generator
    const { videoGenerator } = await import('@/lib/agents/miyomi-video-generator');
    
    // Generate and distribute videos for all platforms
    const result = await videoGenerator.generateAndDistribute(pick);
    
    console.log('Video generation completed:', result.video.id);
    console.log('Distribution URLs:', result.distribution);
    
    // Store distribution info for tracking
    await storeVideoDistribution(pickId, result);
    
    return result.video.url;
    
  } catch (error) {
    console.error('Video generation failed:', error);
    
    // Fallback to basic Eden API if available
    try {
      const edenResponse = await fetch(`${process.env.EDEN_BASE_URL}/api/agents/miyomi/generate-video`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${process.env.EDEN_API_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          agent: 'miyomi',
          pick_id: pickId,
          style: 'contrarian-analysis',
          format: 'vertical-short'
        })
      });

      if (edenResponse.ok) {
        const result = await edenResponse.json();
        return result.video_url;
      }
    } catch (fallbackError) {
      console.error('Fallback Eden API also failed:', fallbackError);
    }
    
    return null;
  }
}

async function storeVideoDistribution(pickId: string, result: any) {
  // Store video URLs and metadata for tracking
  console.log(`Storing video distribution for pick ${pickId}:`, result.distribution);
  // TODO: Save to database
}

async function createDrop(dropData: any) {
  // TODO: Create drop record in database
  // This would insert into your drops table
  
  const dropId = `drop_${Date.now()}`;
  console.log('Creating drop record:', dropId);
  
  return dropId;
}

async function applySponsorship(pick: any) {
  try {
    // Get available sponsorship opportunities
    const opportunities = await revenueEngine.getSponsorshipOpportunities();
    
    // Find matching opportunity for this pick's platform
    const matchingOpp = opportunities.find(opp => 
      opp.platform === pick.platform && opp.isActive
    );

    if (matchingOpp) {
      console.log(`Applying sponsorship from ${matchingOpp.platform} for pick:`, pick.id);
      
      // Create sponsored version of the pick
      const sponsoredPick = await revenueEngine.createSponsoredPick(pick, matchingOpp);
      
      // Track sponsorship application event
      await revenueEngine.trackEvent({
        type: 'click',
        platform: matchingOpp.platform,
        pickId: pick.id,
        value: matchingOpp.rate,
        metadata: {
          sponsorshipType: matchingOpp.type,
          automaticallyApplied: true
        }
      });

      return sponsoredPick;
    }

    // No sponsorship available, return original pick
    return pick;

  } catch (error) {
    console.error('Error applying sponsorship:', error);
    // Return original pick if sponsorship fails
    return pick;
  }
}